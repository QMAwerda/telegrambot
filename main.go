package main

import (
	"flag"
	"log"
)

func main() {
	// consumer получает и обрабатывает события. Для получения у него будет fetcher, а для обработки processor.
	// Значит нам нужно создать fetcher и processor. Они будут работать с API телеграма, получая и отправляя сообщения.
	// Он будет скидывать нам ссылки или ругаться, что не понял команду. Для общения с API им обоим потребудется client.
	// Создим его и передадим ему токен, чтобы было ясно, что именно мы запрашиваем или добавляем статью.
	// token должен быть секретным, иначе могут угнать бота. Нельзя определить его как константу в коде. Правильнее будет
	// передавать его как флаг для запуска программы.

	//token = flags.Get(token)

	//tgClient = telegram.New(token)

	//fetcher = fetcher.New()
	//processor = processor.New()

	//consumer.Start(fetcher, processor)

	// Реализуем:

	t := mustToken()
}

// Начнем с получения токена из флага
// не принято называть фукнкции getToken, потому что get не несет доп смысла, можно назвать просто token
// Вернем токен - строку, а если его не передали в параметрах - вернем ошибку. Так можно, но тогда мы добавим
// в код вызывающей функции еще 3 строки на обработку ошибок. А ведь нет смысла выполнять код без токена.
// уберем ошибку и будем крашить приложение если не выполнилась функция. Кинем панику. Такие функции, которые
// обязательно выполняются, пишутся с приставкой must. С такими функциями надо работать осторожно, применяют
// их нечасто. В основном - запуск программы и парсинг конфигов. Поэтому им не стоит злоупотреблять.
func mustToken() string {
	// первый аргумент - имя флага.
	// второй аргумент - значение флага по умолчанию, но у нас токен обязательный, поэтому пустая строка.
	// третий аргумент - подсказка к флагу - мы сможем ее увидеть когда скомпилируем прогу и будем пытаться ее запускать.
	// в подсказках всегда стоит писать что-то осмысленное, потому что через время можно забыть, зачем вообще тот или иной флаг.
	// при запуске будем писать: bot -tg-bot-token 'mytoken'
	token := flag.String("tg-bot-token", "", "token for access to telegram bot") // парсим текст, поэтому String()
	//в переменной token будет не значение, а ссылка на значение токена. Кстати значение попадает не в момент вызова String(),
	//а в момент вызова Parse()
	flag.Parse()

	// вообще так делать не стоит, потому что ссылка может указывать и на nil и если так, мы получим панику
	// но у нас все безопасно, потому что даже при отсутствии флагов мы получим пустую строку (второй аргумент flag.String())
	// а еще мы сейчас сами кинем log.Fatal(). При ее вызове программа аварийно завершается - os.Exit(1)
	if *token == "" {
		log.Fatal("token is not specified") // пишем сообщение при ошибке, чтоб потом не разбираться, почему программа падает.
	}

	return *token
}
